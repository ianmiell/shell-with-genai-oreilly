== SLIDE 21 - VARIABLES
As in any programming environment, variables are critical to an understanding of bash. In this section you’ll learn about variables in bash and some of their subtleties.
You will cover:
- Basic variables
- Quoting variables
- The `env` and `export` commands
- Simple arrays

== SLIDE 22 - WALKTHROUGH BASICS
Start by creating a variable and echoing it.

 MYSTRING=astring
 echo $MYSTRING

Simple enough: you create a variable by stating its name, immediately adding an equals sign, and then immediately stating the value.
Variables don’t need to be capitalised, but they generally are by convention.
The dollar sign tells bash you want the variable dereferenced. You might wonder how you get an actual dollar echoed, but we will get there soon.

== VARS AND QUOTES

Things get more interesting when you start quoting.
Quoting can be used to group different ‘words’ into a single variable value:

 MYSENTENCE=A sentence
 MYSENTENCE="A sentence"
 echo $MYSENTENCE

The shell reads each word in separated by a space.
It thinks the word ‘sentence’ is not related to the variable assigment treats it as a program
To get the sentence into the variable with the space in it enclose in the double quotes
Things get even more interesting when we embed other variables in the quoted string:

 MYSENTENCE="A sentence with $MYSTRING in it"
 echo $MYSENTENCE

No great surprise. Now Single quotes

 MYSENTENCE='A sentence with $MYSTRING in it'
 echo $MYSENTENCE

If you were expecting similar behaviour to the previous section you may have got a surprise!
The bash shell translates the variable into its value if it’s in double quotes, but does not if it’s in single quotes.
I've spent a lot of time trying to get quotes right in bash (and other languages), so there will be more on this kind of thing.

== SHELL VARIABLES
Some variables are special, and set up when bash starts:

 echo $PPID

`PPID` is a special variable. It contains the bash’s parent process id.

 PPID=nonsense
 echo $PPID

If you want to make a readonly variable, put `readonly` in front of it, like this:

 readonly READONLYVAR=astring
 READONLYMYVAR=anotherstring

You can't unset a readonly (easily, or by design)...

== `export`
You’ve already seen that a variable set in a bash terminal can be referenced later by using the dollar sign.
But what happens when you set a variable, and then start up another process? Can this new process 'see' that variable?
That depends:

 MYSTRING=astring
 bash

Simple string, and new bash process

 echo $MYSTRING

Where is it?

 exit

Quit and see it again:

 echo $MYSTRING

unset it

 unset MYSTRING

it's gone

 echo $MYSTRING

Same again, but this time export it

 export MYSTRING=anotherstring
 bash
 echo $MYSTRING

Now it's there:

 exit

Bit like inheritance. It’s not just shells that have environment variables! All processes have environment variables.
An example of bash leading to  more fundamental points about software...

== Outputting Exported and Shell Variables
Wherever you are, you can see the exported variables that are set by running `env`:

 env

The output of `env` will likely be different wherever you run it.
That isn't all the variables that are set in your shell, though. It's just the _environment_ variables that are exported to processes that you start in the shell.
If you want to see all the variables that are available to you in your shell, type:

 declare

Gives you variables and functions set up in your environment. Functions are technically a kind of variable.

 declare -f  # just functions
 declare -F  # just function headers
 declare -r  # readonlys
 declare -i  # just integers

== ARRAYS
Worth mentioning here also are arrays. As in other languages, arrays in bash are zero-indexed.
Declare -a shows all the arrays - you can see BASH_VERSINFO there.

 declare -a

Highlight BASH_VERSINFO
The first thing to notice is that if the array will output the item at the first element (0) if no index is given:

 echo $BASH_VERSINFO

Try with a 'standard' way of referencing arrays:

 echo $BASH_VERSINFO[0]

But that doesn't work - why? Need to use braces:

 echo ${BASH_VERSINFO[0]}

Generally good practice to indicate what the variable name is with braces. sign of experienced bash user

 echo $BASH_VERSION_and_some_string
 echo ${BASH_VERSION}_and_some_string

By default, bash arrays give you the 0th element, so it looks like a simple variable.

 echo ${BASH_VERSINFO}

In fact, ‘simple variables’ can be treated as arrays with one element!

 unset A
 echo $A
 A=1
 echo $A
 echo ${A[0]}
 echo ${A[1]}

So all bash variables are ‘really’ arrays!
Arrays can be tricky to deal with, and bash doesn’t give you much help!
As ever with variables, if the item does not exist then the output will be an empty line.
