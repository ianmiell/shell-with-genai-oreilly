== Internal Field Separator
This mouthful is important to know about if you are going to shell script. You will cover:

- What the `IFS` variable is for
- When it should be used
- How to set it up
- Ways of dealing with odd filenames in loops

== Files With Spaces
Create a folder to work in:

 mkdir bns_ifs && cd bns_ifs

Now create a couple of files with spaces in:

 echo file1 created > "Spaces in filename1.txt"
 cat "Spaces in filename1.txt"
 echo file2 created > "Spaces in filename2.txt"
 cat "Spaces in filename2.txt"

Note that you have to quote the filename to get the spaces in.  Without the quotes, bash treats the space as a token separator.  This means that it would treat the redirection as going to the file 'Spaces' and not know what to do with the 'in' and 'filenameN.txt' tokens.
Now if you write a for loop over these files that just runs `ls` on each file in turn, you might not get what you expect.

 for f in $(ls)
 do
   ls $f
 done

Hmmm. The for loop has treated every word in the filenames as a separate token to look for with `ls`. In other words, bash has treated each space as a 'field separator'.  Normally this is fine, as our for loops have items separated by spaces, like this:

 for f in 1 2 3 4
 do
   echo $f
 done

or even

 for f in $(echo 1 2 3 4)
 do
   echo $f
 done

However, here we want the spaces to be ignored. And we can control this by setting the `IFS` shell variable.

=== The IFS Shell Variable

 echo $IFS

If you retained the default, then you will have seen nothing in the output, which isn't very helpful. To see how it's really set up, we can use `set`:

 set | grep IFS

You should see output like this:

 IFS=$' \t\n'

The `$` before the single quotes means that the variable is showing you special characters with the backlash escape notation. Above, the `IFS` variable is set to: space, tab, and newline. It is a very handy way of safely putting special characters into a string. This is super-useful as you get more into bash.

 man ascii

gives a table of characters. If you want to output a specific char, you can, eg the vertical tab:

 echo $'a\x0bb\x0bc'

If you take bash seriously, you will get into looking at terminal special characters like this.

Bash to IFS. Bash takes the characters in that variable and will treat any of them as a field separator, which means that the original for loop you wrote above will create from these files:

 Spaces in filename1.txt
 Spaces in filename2.txt

these list of items:

 Spaces
 in
 filename1.txt
 Spaces
 in
 filename2.txt

What we want to do is treat the spaces like any other character.
We can do this by altering the IFS variable to remove the space and re-running the
for loop:

 IFS=$'\t\n'
 for f in $(ls)
 do
   ls $f
 done

=== The Null Byte as Separator
While we're on the subject, it's worth mentioning quickly a pattern that's very commonly-used to get around the above scenario.

 find . -type f -print0

Uses the NUL byte as a separator. The NUL byte doesn't get printed to the terminal, so you don't see anything, but it is there.

 find . -type f -print0 | wc -c

Other programs have flags that can read these NULs in the input. eg this fails:

 find . -type f -print0 | xargs grep -n1 file

but this is ok:

 find . -type f -print0 | xargs -0 grep file

By adding the `-print0` flag, find no longer uses a new line as a field separator. It uses what's called a `NUL` byte as the separator. The `NUL` byte is literally a byte of value zero.  It doesn't get displayed on the screen, but can be read by `xargs` as the separator if it's given the `-0` flag. This bypasses all sorts of challenges you might get fiddling with the `IFS` variable or dealing with spaces or other odd characters in filenames.
