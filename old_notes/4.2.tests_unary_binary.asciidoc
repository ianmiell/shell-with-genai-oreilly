== Unary and Binary Operators

There are other shortcuts relating to `test` (and its variants) that it’s worth knowing about. These take a single argument:
-z returns true if the variable is unset or empty

 unset DOESNOTEXIST
 echo $DOESNOTEXIST
 [ -z "$DOESNOTEXIST" ]
 echo $?

Interestingly, this test is OK with no argument! Just another confusing point about tests...

 [ -z ]
 echo $?

There are quite a few unary operators so I won’t cover them all here. The ones I use most often are `-a` and `-d`.
`-z` returns true if the variable is empty, `-a` returns true if the given file exists, and `-d` if the given directory exists.

There are many of these unary operators, but the differences between them are useful only in the rare cases when you need them. Generally I just use `-d`, `-a`, and `-z` and look up the others when I need something else.
We’ll cover ‘binary operators’, which work on two arguments, while covering types in bash.

=== Types
Type-safety (if you’re familiar with that concept from other languages) does not come up often in bash as an issue. But it is still significant.

 [[ 10 < 2 ]]
 echo $?

Although 10 < 2 should be false if we consider them as numbers, it returns true because, as strings, 10 is earlier alphabetically than 2. Same result in quotes.

 [[ '10' < '2' ]]
 echo $?

Now look at:

 [ 10 -lt 2 ]
 echo $?

OK, that's false.

 [[ 1 -lt 2 ]]
 echo $?

The binary operators used above are: `-lt` (less than), `-gt` (greater than), `-eq` (equals), and `-ne` (not equals). They deal happily with integers in single bracket tests.
Declare -i gives you variables marked as integers.
It doesn't care if the numbers are in quotes, still trets them as numbers:

 [[ '10' -gt '2' ]]
 echo $?

 declare -i
