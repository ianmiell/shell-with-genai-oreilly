== DISCUSSION - LAST WEEK'S HOMEWORK

See 4.2 from week_one.

== SLIDE 27 - Pipes and redirects

Pipes and redirects are used very frequently. This can cause a problem. You think you 'know' how they work and never look more deeply into it.
In this section you'll cover:
- Redirects
- Pipes
- Standard out (stdout) vs standard error (stderr)
- File descriptors
It's probably the most difficult part of this course to teach and follow, so if it doesn't all go in do not worry, but try and take what you can from it. First, let's have an overview.

== Overview
TALK ABOUT FIRST SLIDE - OVERVIEW OF PROCESS/CHANNELS

Start off by creating a file:

 mkdir pipes
 cd pipes
 echo "contents of file" > sometext

Didn't go to screen. '>' takes output from command creates file. echo goes into it.

 cat sometext

Now I'm going to show you some magic, but you will have to bear with me. The magic is that not all output is treated the same on your terminal.
Some of the output is called 'standard output' and some of the output is called 'standard error'. Try and remember this as we go through.

=== Basic Pipes
Type this in:

 cat sometext | grep -c file

Here -c counts the number of matches.
Normally you’d run a grep with the filename as the last argument, but instead here we pipe the contents of `sometext` into the grep command by using the pipe operator, so named because it looks like a pipe.
It takes the standard output of one command and passes it as the input to another. What is standard output?

== Standard Output vs Standard Error
So far so simple. Create an error by calling non-existent file:

 cat doesnotexist

See the word file. If I grep for file, what will happen
Now what will this output?

 cat doesnotexist | grep -c file

Surprised? To understand what's going on here we need to take a step outside for a moment.

In Linux, every running process gets a number of 'file descriptors'.
What is a file descriptor? A file descriptor is a number for some stream of data. Like a numbered house might have people in it separated from people in other houses, this number refers to a set of data.

== SLIDE 28 - File descriptors (I)
When we redirect using '>', we use the file descriptor 1 == standard output, which is the default.
By default when you write with echo you write to standard output, which is also written to the terminal by default, because the file descriptor is pointed at the terminal.
But you can write to another file descriptor called 'standard error', which has the number '2'.
Going back to the cat command:

 cat doesnotexist | grep -c file

When the cat command errors, it writes to this standard error file descriptor, not standard output.
BUT normally this file descriptor writes to the terminal too so you don't see a different usually!

You can redirect this 'standard error' output to a file too:

 cat doesnotexist                      # standard error (2) and standard output (1) goes to terminal
 cat doesnotexist > nothing            # standard output (1) goes to 'nothing'
 cat doesnotexist 2> someerrortext     # standard output (2) goes to 'someerrortext'
 cat someerrortext                     # error in here

Now, back to pipes: a PIPE is only interested in reading standard output.
It doesn't care about what gets written to file descriptor 2 (the error file).
As a result, it is NOT passed through the pipe to the grep command, and grep counts 0 matches in its output.
To the viewer of the terminal, there is no difference, but to bash there is all the difference in the world!
This is important. It's the source of a lot of confusion.
When you redirect standard output to a file, you use the redirection operator.  Implicitly, you are using the '1' file descriptor.
So these are the same:

 echo sometext > afile
 echo sometext 1> afile

== SLIDE 29 - File descriptors (II)

== Differences Between Pipes and Redirects

To recap:
-   A pipe passes ‘standard output’ as the ‘standard input’ to another command
-   A redirect sends a stream of output to a file
A couple of other commonly used operators are worth mentioning here:
The first two lines above use the `>` operator, while the third one uses the `>>` operator. The `>` operator effectively creates the file anew whether it already exists or not. The `>>` operator, by contrast, *appends* to the end of the file. As a result, only `line2` and `line3` are added to `file3`.

== 2>&1

#!/bin/bash
echo to standard output
toerroroutput

== EXERCISE: https://learning.oreilly.com/scenarios/bash-fundamentals-challenge/9781098138547/

== SOLUTION

## Task 1 Solution

cat > /root/output.sh << EOF
#!/bin/bash
echo standard output
echo standard error 1>&2
EOF
chmod +x /root/output.sh

## Task 2 Solution

cat > /root/outputfile.sh << EOF
#!/bin/bash
./output.sh > stdout.log 2> stderr.log
EOF
chmod +x /root/outputfile.sh

## Task 3 Solution
echo './output.sh > all.log 2>&1' >> outputfile.sh
